name: SWFT Container CI/CD

on:
  push:
    branches: [ main, spike-appdesign ]
    paths:
      - 'samples/fastapi-demo/**'
      - 'backend/**'
      - 'frontend/**'
      - 'Dockerfile'
      - 'backend/Dockerfile'
      - 'frontend/Dockerfile'
      - 'main.py'
      - 'pyproject.toml'
      - 'uv.lock'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      project_name:
        description: "Logical Project Name for SWFT tracking"
        type: string
        default: "swft-demo"
      upload_to_azure:
        description: "Upload SBOM/scan/run JSON to Azure Storage (RBAC via azure/login)"
        type: boolean
        default: true
      upload_artifacts:
        description: "Upload SBOM/scan/run JSON as GitHub Artifacts"
        type: boolean
        default: true
      trivy_config:
        description: "scan=<levels>;ignore_unfixed=<true|false>;fail=<levels>"
        type: string
        default: "scan=HIGH,CRITICAL;ignore_unfixed=true;fail=CRITICAL"
      storage_containers:
        description: "sboms,scans,runs,appdesign"
        type: string
        default: "sboms,scans,runs,appdesign"
      fail_on_trivy:
        description: "Fail the workflow if FAIL set has findings (manual runs only)"
        type: boolean
        default: false
      fail_on_cosign_verify:
        description: "Fail the workflow if Cosign verify fails"
        type: boolean
        default: true

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  # Registry
  ACR_LOGIN_SERVER:     ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_USERNAME:         ${{ secrets.ACR_USERNAME }}
  ACR_PASSWORD:         ${{ secrets.ACR_PASSWORD }}
  # Shared tag applied to every matrix entry; swap to github.sha if you prefer immutable tags.
  IMAGE_TAG:            ${{ secrets.IMAGE_TAG }}

  # Azure targets
  AZURE_RESOURCE_GROUP: demo-swft-cicd
  AZURE_CONTAINER_NAME: swft-fastapi
  AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}

  # Defaults for push runs (used if no override via trivy_config)
  TRIVY_SEVERITY:       HIGH,CRITICAL
  TRIVY_IGNORE_UNFIXED: true

  # Names & IDs
  PROJECT_NAME: ${{ github.event_name == 'workflow_dispatch' && inputs.project_name || vars.PROJECT_NAME || github.event.repository.name }}
  RUN_ID:       ${{ github.run_id }}
  RUN_NUMBER:   ${{ github.run_number }}

  # FIXED artifact filenames (we always create & upload these)
  # Keep the canonical names here so every step references the same variables.
  SBOM_SRC:     sbom.cyclonedx.json
  TRIVY_SRC:    trivy-report.json
  SARIF_SRC:    trivy-results.sarif
  DEPLOY_SRC:   aci-endpoint.txt
  RUNJSON_SRC:  run.json
  APPDESIGN_SRC: app-design.md

jobs:
  # End-to-end pipeline: build the container, scan/sign it, ship artifacts, and redeploy the demo.
  build-and-deploy:
    runs-on: ubuntu-latest
    defaults: { run: { shell: bash } }
    # Matrix controls which containers are built/scanned; add new entries for frontend/backend as you onboard them.
    strategy:
      fail-fast: false
      matrix:
        target:
          - name: sample-fastapi
            context: ./samples/fastapi-demo
            dockerfile: ./samples/fastapi-demo/Dockerfile
            image_name: fastapi-demo
            deploy: true  # Set to true only for images that should be redeployed to ACI during the workflow run.
          - name: backend
            context: .
            dockerfile: ./backend/Dockerfile
            image_name: swft-backend
            deploy: false
          - name: frontend
            context: ./frontend
            dockerfile: ./frontend/Dockerfile
            image_name: swft-frontend
            deploy: false
    # TARGET_* env vars make the matrix data easy to consume in shell steps and action inputs.
    env:
      TARGET_NAME: ${{ matrix.target.name }}
      TARGET_CONTEXT: ${{ matrix.target.context }}
      TARGET_DOCKERFILE: ${{ matrix.target.dockerfile }}
      TARGET_IMAGE_NAME: ${{ matrix.target.image_name }}
      TARGET_DEPLOY: ${{ matrix.target.deploy && 'true' || 'false' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Log in with the service principal so az CLI and Docker share the same credentials.
      - name: Azure Login (Service Principal, AzureCloud)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          environment: azureCloud

      # Stamp each run with predictable filenames and a UTC timestamp for traceability later.
      # Including TARGET_NAME keeps artifact prefixes unique per matrix entry; the backend treats this prefix as the project_id shown in the UI.
      - name: Derive pretty names & timestamp
        run: |
          set -euo pipefail
          FILE_PREFIX="${PROJECT_NAME}-${TARGET_NAME}-${RUN_ID}"
          {
            echo "FILE_PREFIX=$FILE_PREFIX"
            echo "SBOM_FILE=${FILE_PREFIX}-sbom.json"
            echo "TRIVY_FILE=${FILE_PREFIX}-trivy.json"
            echo "SARIF_FILE=${FILE_PREFIX}-trivy.sarif"
            echo "DEPLOY_FILE=${FILE_PREFIX}-deploy.txt"
            echo "RUN_JSON_FILE=${FILE_PREFIX}-run.json"
            echo "APPDESIGN_FILE=${FILE_PREFIX}-appdesign.md"
            echo "ACTIONS_RUN_URL=https://github.com/${GITHUB_REPOSITORY}/actions/runs/${RUN_ID}"
            echo "RUN_TIMESTAMP=$(date -u +%FT%TZ)"
          } >> $GITHUB_ENV

      # Fold all manual inputs and repo defaults into a single set of outputs for downstream steps.
      - name: Parse inputs (Trivy + containers + switches)
        id: cfg
        run: |
          set -euo pipefail
          # ---- Trivy config
          TC="${{ github.event_name == 'workflow_dispatch' && inputs.trivy_config || '' }}"
          [ -z "$TC" ] && TC="scan=${TRIVY_SEVERITY};ignore_unfixed=${TRIVY_IGNORE_UNFIXED};fail=CRITICAL"
          SCAN=$(echo "$TC" | sed -n 's/.*scan=\([^;]*\).*/\1/p'); [ -z "$SCAN" ] && SCAN="${TRIVY_SEVERITY}"
          IGN=$(echo "$TC"  | sed -n 's/.*ignore_unfixed=\([^;]*\).*/\1/p'); [ -z "$IGN" ] && IGN="${TRIVY_IGNORE_UNFIXED}"
          FAIL=$(echo "$TC" | sed -n 's/.*fail=\([^;]*\).*/\1/p'); [ -z "$FAIL" ] && FAIL="CRITICAL"
          echo "scan_levels=$SCAN"         >> $GITHUB_OUTPUT
          echo "ignore_unfixed=$IGN"       >> $GITHUB_OUTPUT
          echo "fail_levels=$FAIL"         >> $GITHUB_OUTPUT

          # ---- Containers
          CS="${{ github.event_name == 'workflow_dispatch' && inputs.storage_containers || '' }}"
          [ -z "$CS" ] && CS="sboms,scans,runs"
          IFS=',' read -r CN_SBOM CN_SCAN CN_RUNS CN_APPDESIGN <<< "$CS"
          echo "cn_sbom=${CN_SBOM:-sboms}" >> $GITHUB_OUTPUT
          echo "cn_scan=${CN_SCAN:-scans}" >> $GITHUB_OUTPUT
          echo "cn_runs=${CN_RUNS:-runs}"  >> $GITHUB_OUTPUT
          echo "cn_appdesign=${CN_APPDESIGN:-appdesign}" >> $GITHUB_OUTPUT

          # ---- Effective switches (works for push AND manual)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            AZ="${{ inputs.upload_to_azure }}"
            AR="${{ inputs.upload_artifacts }}"
          else
            AZ="${{ vars.UPLOAD_TO_AZURE || 'true' }}"
            AR="${{ vars.UPLOAD_ARTIFACTS || 'true' }}"
          fi
          echo "upload_to_azure=$AZ"  >> $GITHUB_OUTPUT
          echo "upload_artifacts=$AR" >> $GITHUB_OUTPUT

      - name: Debug upload targets
        run: |
          set -euo pipefail
          echo "=== Upload debug information ==="
          echo "Account: ${AZURE_STORAGE_ACCOUNT}"
          echo "Matrix target: ${TARGET_NAME}"
          echo "Containers:"
          echo "  SBOM:      ${{ steps.cfg.outputs.cn_sbom }}"
          echo "  Trivy:     ${{ steps.cfg.outputs.cn_scan }}"
          echo "  Runs:      ${{ steps.cfg.outputs.cn_runs }}"
          echo "  AppDesign: ${{ steps.cfg.outputs.cn_appdesign }}"
          echo "================================="

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Log in to the registry before we try to push the freshly built image.
      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ACR_LOGIN_SERVER }}
          username: ${{ env.ACR_USERNAME }}
          password: ${{ env.ACR_PASSWORD }}

      # Build the sample FastAPI image and push it straight to ACR.
      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.TARGET_CONTEXT }}
          file: ${{ env.TARGET_DOCKERFILE }}
          push: true
          tags: ${{ env.ACR_LOGIN_SERVER }}/${{ env.TARGET_IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      # Pull the exact tag back down so scanners and cosign work against the same bits we just published.
      - name: Pull image for local scan
        run: docker pull "${{ env.ACR_LOGIN_SERVER }}/${{ env.TARGET_IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

      # Capture the immutable digest; every signing and upload step keys off this value.
      - name: Get image digest
        run: |
          set -euo pipefail
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "${ACR_LOGIN_SERVER}/${TARGET_IMAGE_NAME}:${IMAGE_TAG}" | awk -F'@' '{print $2}')
          echo "IMAGE_DIGEST=$DIGEST" >> $GITHUB_ENV

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.9.0

      # Cosign expects plain files, so decode the base64 secrets before signing.
      - name: Decode Cosign keys
        run: |
          set -euo pipefail
          echo "${{ secrets.COSIGN_KEY_B64 }}" | base64 -d > cosign.key
          chmod 600 cosign.key
          echo "${{ secrets.COSIGN_PUB_KEY_B64 }}" | base64 -d > cosign.pub
          chmod 644 cosign.pub

      # Sign the pushed image by digest; we skip the transparency log for repeatability in demos.
      - name: Sign image (by digest, no tlog)
        run: |
          set -euo pipefail
          REF="${ACR_LOGIN_SERVER}/${TARGET_IMAGE_NAME}@${IMAGE_DIGEST}"
          cosign sign --key cosign.key --tlog-upload=false "$REF"

      - name: Verify image signature (by digest; ignore tlog)
        env:
          POLICY_FAIL_ON_VERIFY: ${{ github.event_name == 'workflow_dispatch' && inputs.fail_on_cosign_verify || 'true' }}
        # Keep the run going even if verification fails so we can optionally report the failure later.
        run: |
          set +e
          REF="${ACR_LOGIN_SERVER}/${TARGET_IMAGE_NAME}@${IMAGE_DIGEST}"
          cosign verify --key cosign.pub --insecure-ignore-tlog "$REF" >/tmp/cosign.verify 2>&1
          STATUS=$?
          set -e
          if [ $STATUS -eq 0 ]; then
            echo "COSIGN_VERIFY_STATUS=passed" >> $GITHUB_ENV
          else
            echo "COSIGN_VERIFY_STATUS=failed" >> $GITHUB_ENV
            echo "--- cosign verify output ---"; cat /tmp/cosign.verify || true; echo "---------------------------"
            if [ "$POLICY_FAIL_ON_VERIFY" = "true" ]; then exit 1; fi
          fi

      # === GENERATE FILES WITH OFFICIAL ACTIONS (fixed names) ===
      - name: Generate SBOM (Syft via Anchore)
        uses: anchore/sbom-action@v0.20.1
        with:
          image:        ${{ env.ACR_LOGIN_SERVER }}/${{ env.TARGET_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format:       cyclonedx-json
          output-file:  sbom.cyclonedx.json
          upload-artifact: false

      - name: Verify SBOM exists
        run: |
          set -euo pipefail
          test -s "sbom.cyclonedx.json" || { echo "SBOM not created"; ls -la; exit 2; }

      - name: Run Trivy vulnerability scanner (JSON)
        uses: aquasecurity/trivy-action@0.34.0
        env:
          TRIVY_USERNAME: ${{ env.ACR_USERNAME }}
          TRIVY_PASSWORD: ${{ env.ACR_PASSWORD }}
        with:
          version: 'v0.69.0'
          scan-type: 'image'
          image-ref: ${{ env.ACR_LOGIN_SERVER }}/${{ env.TARGET_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: 'json'
          output: trivy-report.json
          severity: ${{ steps.cfg.outputs.scan_levels }}
          ignore-unfixed: ${{ steps.cfg.outputs.ignore_unfixed }}
          scanners: 'vuln'
          exit-code: '0'

      - name: Verify Trivy JSON exists
        run: |
          set -euo pipefail
          test -s "trivy-report.json" || { echo "Trivy JSON not created"; ls -la; exit 2; }

      - name: Capture Trivy scanner metadata
        run: |
          set -euo pipefail
          TRIVY_VERSION_RAW=$(trivy --version 2>/dev/null || true)
          TRIVY_VERSION=$(echo "$TRIVY_VERSION_RAW" | awk -F': ' '/^Version:/ {print $2; exit}')
          TRIVY_DB_UPDATED=$(echo "$TRIVY_VERSION_RAW" | awk -F': ' '/UpdatedAt:/ {print $2; exit}')
          if [ -z "$TRIVY_DB_UPDATED" ]; then
            DB_INFO_JSON=$(trivy --cache-dir "${HOME}/.cache/trivy" db info --format json 2>/dev/null || trivy db info --format json 2>/dev/null || echo "")
            if [ -n "$DB_INFO_JSON" ] && command -v jq >/dev/null 2>&1; then
              TRIVY_DB_UPDATED=$(echo "$DB_INFO_JSON" | jq -r '.UpdatedAt // .updated_at // empty')
            fi
          fi
          if [ -n "$TRIVY_VERSION" ]; then
            echo "TRIVY_SCANNER_VERSION=$TRIVY_VERSION" >> "$GITHUB_ENV"
          fi
          if [ -n "$TRIVY_DB_UPDATED" ]; then
            echo "TRIVY_DB_UPDATED=$TRIVY_DB_UPDATED" >> "$GITHUB_ENV"
          fi

      - name: Generate Trivy SARIF
        uses: aquasecurity/trivy-action@0.34.0
        with:
          version: 'v0.69.0'
          scan-type: 'image'
          image-ref: ${{ env.ACR_LOGIN_SERVER }}/${{ env.TARGET_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: trivy-results.sarif
          severity: ${{ steps.cfg.outputs.scan_levels }}
          ignore-unfixed: ${{ steps.cfg.outputs.ignore_unfixed }}
          scanners: 'vuln'
          exit-code: '0'

      - name: Verify Trivy SARIF exists
        run: |
          set -euo pipefail
          test -s "trivy-results.sarif" || { echo "Trivy SARIF not created"; ls -la; exit 2; }

      - name: Ensure jq present (for policy)
        run: jq --version || (sudo apt-get update -y && sudo apt-get install -y jq)

      - name: Enforce Trivy policy (fail only on selected severities)
        env:
          POLICY_FAIL_ON_TRIVY:  ${{ github.event_name == 'workflow_dispatch' && inputs.fail_on_trivy || (vars.FAIL_ON_TRIVY || 'false') }}
          SCAN_LEVELS:           ${{ steps.cfg.outputs.scan_levels }}
          FAIL_LEVELS:           ${{ steps.cfg.outputs.fail_levels }}
        run: |
          set -euo pipefail
          TOTAL_COUNT=$(jq --arg sev "$SCAN_LEVELS" '
            [ .Results[].Vulnerabilities[]? as $v
              | ($sev | split(",")) as $levels
              | select($levels | index($v.Severity))
            ] | length' "trivy-report.json")
          FAIL_COUNT=$(jq --arg sev "$FAIL_LEVELS" '
            [ .Results[].Vulnerabilities[]? as $v
              | ($sev | split(",")) as $levels
              | select($levels | index($v.Severity))
            ] | length' "trivy-report.json")
          echo "TRIVY_FINDINGS_TOTAL=$TOTAL_COUNT" >> $GITHUB_ENV
          echo "TRIVY_FINDINGS_FAILSET=$FAIL_COUNT" >> $GITHUB_ENV
          if [ "${TARGET_DEPLOY}" != "true" ]; then
            echo "Skipping Trivy enforcement for scan-only target ${TARGET_NAME}; findings recorded for reporting only."
            exit 0
          fi
          if [ "$POLICY_FAIL_ON_TRIVY" = "true" ] && [ "$FAIL_COUNT" -gt 0 ]; then
            echo "Failing due to findings in fail set ($FAIL_LEVELS): $FAIL_COUNT"
            exit 1
          fi

      - name: Upload SARIF to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-results.sarif
          category: trivy-container
        # Explicit category keeps successive Trivy uploads linked to the same analyzer so old alerts get closed.

      # ---------- Azure uploads (work on push and manual; FLAT filenames) ----------
      # Make sure the three blob containers exist before we start uploading files.
      - name: Ensure Azure containers
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            az storage container create --name "${{ steps.cfg.outputs.cn_sbom }}" --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null
            az storage container create --name "${{ steps.cfg.outputs.cn_scan }}" --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null
            az storage container create --name "${{ steps.cfg.outputs.cn_runs }}" --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null
            az storage container create --name "${{ steps.cfg.outputs.cn_appdesign }}" --account-name "${AZURE_STORAGE_ACCOUNT}" --auth-mode login >/dev/null

      # Copy the SBOM to a run-scoped filename and push it into the chosen container.
      - name: Upload SBOM to Azure Storage (flat name)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            cp -f "sbom.cyclonedx.json" "${SBOM_FILE}"
            az storage blob upload --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_sbom }}" --file "${SBOM_FILE}" --name "${SBOM_FILE}" --overwrite true --auth-mode login
            SBOM_URL=$(az storage blob url --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_sbom }}" --name "${SBOM_FILE}" -o tsv)
            echo "SBOM_URL=$SBOM_URL" >> $GITHUB_ENV

      # Do the same for the Trivy report so the backend can grab it by RUN_ID.
      - name: Upload Trivy report to Azure Storage (flat name)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            cp -f "trivy-report.json" "${TRIVY_FILE}"
            az storage blob upload --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_scan }}" --file "${TRIVY_FILE}" --name "${TRIVY_FILE}" --overwrite true --auth-mode login
            TRIVY_URL=$(az storage blob url --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_scan }}" --name "${TRIVY_FILE}" -o tsv)
            echo "TRIVY_URL=$TRIVY_URL" >> $GITHUB_ENV

      - name: Upload app-design.md to Azure Storage (flat name)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            if [ ! -f "${APPDESIGN_SRC}" ]; then
              echo "app-design.md missing in repository; skipping upload."
              exit 0
            fi
            cp -f "${APPDESIGN_SRC}" "${APPDESIGN_FILE}"
            az storage blob upload --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_appdesign }}" --file "${APPDESIGN_FILE}" --name "${APPDESIGN_FILE}" --overwrite true --auth-mode login
            APPDESIGN_URL=$(az storage blob url --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_appdesign }}" --name "${APPDESIGN_FILE}" -o tsv)
            echo "APPDESIGN_URL=$APPDESIGN_URL" >> $GITHUB_ENV
            echo "APPDESIGN_PRESENT=true" >> $GITHUB_ENV

      # ---------- Upload each artifact as a single file ----------
      # Always stash a copy in GitHub Artifacts so we have an easy download, even if Azure is disabled.
      - name: Upload SBOM artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('sbom.cyclonedx.json') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ env.PROJECT_NAME }}-${{ env.TARGET_NAME }}-${{ env.RUN_ID }}-attempt${{ github.run_attempt }}
          path: sbom.cyclonedx.json

      - name: Upload Trivy JSON artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('trivy-report.json') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-json-${{ env.PROJECT_NAME }}-${{ env.TARGET_NAME }}-${{ env.RUN_ID }}-attempt${{ github.run_attempt }}
          path: trivy-report.json

      - name: Upload Trivy SARIF artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('trivy-results.sarif') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: trivy-sarif-${{ env.PROJECT_NAME }}-${{ env.TARGET_NAME }}-${{ env.RUN_ID }}-attempt${{ github.run_attempt }}
          path: trivy-results.sarif

      - name: Upload app-design artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('app-design.md') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: appdesign-${{ env.PROJECT_NAME }}-${{ env.TARGET_NAME }}-${{ env.RUN_ID }}-attempt${{ github.run_attempt }}
          path: ${{ env.APPDESIGN_SRC }}

      # ---------- Deploy to Azure Container Instances (CLI) ----------
      # Recreate the demo container so we can show the freshly scanned image running in ACI.
      # TARGET_DEPLOY gates this entire block so scan-only targets skip infrastructure work.
      - name: Deploy to Azure Container Instance
        if: ${{ env.TARGET_DEPLOY == 'true' }}
        run: |
          set -euo pipefail
          if az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" --only-show-errors --output none 2>/dev/null; then
            az container delete --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" --yes
            for i in {1..30}; do
              if ! az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" &>/dev/null; then break; fi
              sleep 5
            done
          fi
          az container create \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --name "$AZURE_CONTAINER_NAME" \
            --image "$ACR_LOGIN_SERVER/$TARGET_IMAGE_NAME:$IMAGE_TAG" \
            --registry-login-server "$ACR_LOGIN_SERVER" \
            --registry-username     "$ACR_USERNAME" \
            --registry-password     "$ACR_PASSWORD" \
            --cpu 1 --memory 1 \
            --os-type Linux \
            --ports 80 \
            --ip-address Public
          PUBLIC_IP=$(az container show --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_CONTAINER_NAME" --query "ipAddress.ip" -o tsv)
          echo "http://$PUBLIC_IP" > "${DEPLOY_SRC}"
          echo "ACI_URL=http://${PUBLIC_IP}" >> $GITHUB_ENV
          test -s "${DEPLOY_SRC}"

      - name: Upload deploy endpoint artifact
        if: ${{ always() && env.TARGET_DEPLOY == 'true' && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('aci-endpoint.txt') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: aci-deploy-info-${{ env.PROJECT_NAME }}-${{ env.TARGET_NAME }}-${{ env.RUN_ID }}-attempt${{ github.run_attempt }}
          path: aci-endpoint.txt

      # ---------- Build RUN JSON AFTER Azure uploads & Deploy ----------
      - name: Ensure jq present (for RUN JSON)
        run: jq --version || (sudo apt-get update -y && sudo apt-get install -y jq)

      # Gather all the metadata we collected into the canonical run.json document.
      - name: Build run JSON payload (fixed jq program)
        id: build_run_json
        run: |
          set -euo pipefail
          if [ "${TARGET_DEPLOY}" = "true" ]; then
            ACI_NAME_VALUE="${AZURE_CONTAINER_NAME}"
            ACI_RG_VALUE="${AZURE_RESOURCE_GROUP}"
          else
            ACI_NAME_VALUE=""
            ACI_RG_VALUE=""
          fi
          SBOM_LINK="${SBOM_URL:-}"
          TRIVY_LINK="${TRIVY_URL:-}"
          jq -n \
            --arg id              "${RUN_ID}" \
            --arg projectName     "${PROJECT_NAME}" \
            --arg runNumber       "${RUN_NUMBER}" \
            --arg repo            "${GITHUB_REPOSITORY}" \
            --arg workflow        "${GITHUB_WORKFLOW}" \
            --arg ref             "${GITHUB_REF}" \
            --arg sha             "${GITHUB_SHA}" \
            --arg timestamp       "${RUN_TIMESTAMP}" \
            --arg actionsRunUrl   "${ACTIONS_RUN_URL}" \
            --arg acr             "${ACR_LOGIN_SERVER}" \
            --arg imageName       "${TARGET_IMAGE_NAME}" \
            --arg imageTag        "${IMAGE_TAG}" \
            --arg imageDigest     "${IMAGE_DIGEST}" \
            --arg sbomFile        "${SBOM_FILE}" \
            --arg trivyFile       "${TRIVY_FILE}" \
            --arg sarifFile       "${SARIF_FILE}" \
            --arg sbomUrl         "${SBOM_LINK}" \
            --arg trivyUrl        "${TRIVY_LINK}" \
            --arg appDesignFile   "${APPDESIGN_FILE:-}" \
            --arg appDesignUrl    "${APPDESIGN_URL:-}" \
            --arg imageRole       "${TARGET_NAME}" \
            --arg aciName         "${ACI_NAME_VALUE}" \
            --arg aciRg           "${ACI_RG_VALUE}" \
            --arg aciUrl          "${ACI_URL:-}" \
            --arg cosignStatus    "${COSIGN_VERIFY_STATUS:-unknown}" \
            --arg sevLevels       "${{ steps.cfg.outputs.scan_levels }}" \
            --arg failLevels      "${{ steps.cfg.outputs.fail_levels }}" \
            --arg trivyVersion    "${TRIVY_SCANNER_VERSION:-}" \
            --arg trivyDbUpdated  "${TRIVY_DB_UPDATED:-}" \
            --argjson ignoreUnfix ${{ steps.cfg.outputs.ignore_unfixed }} \
            --argjson totalFindings ${TRIVY_FINDINGS_TOTAL:-0} \
            --argjson failFindings  ${TRIVY_FINDINGS_FAILSET:-0} \
            '
            def azure_links:
              [
                { key: "sbom", value: $sbomUrl },
                { key: "trivy", value: $trivyUrl },
                { key: "appDesign", value: $appDesignUrl }
              ]
              | reduce .[] as $item ({};
                  if ($item.value | length) > 0
                  then . + { ($item.key): $item.value }
                  else .
                  end
                )
              | (if (keys | length) > 0 then . else null end);

            {
              id: $id,
              projectName: $projectName,
              createdAt: $timestamp,
              repository: $repo,
              workflow: $workflow,
              ref: $ref,
              commitSha: $sha,
              run: { id: $id, number: $runNumber, url: $actionsRunUrl },
              image: { registry: $acr, name: $imageName, tag: $imageTag, digest: $imageDigest },
              imageRole: $imageRole,
              artifacts: {
                azure: azure_links,
                files: {
                  sbom: $sbomFile,
                  trivy: $trivyFile,
                  sarif: $sarifFile,
                  appDesign: (if ($appDesignUrl | length) > 0 then $appDesignFile else null end)
                }
              },
              assessment: {
                cosign: { verifyStatus: $cosignStatus },
                trivy: {
                  scanSeverities: $sevLevels,
                  ignoreUnfixed: $ignoreUnfix,
                  failSeverities: $failLevels,
                  scanner: {
                    version: (if ($trivyVersion | length) > 0 then $trivyVersion else null end),
                    dbUpdatedAt: (if ($trivyDbUpdated | length) > 0 then $trivyDbUpdated else null end)
                  },
                  findings: { total: $totalFindings, failSet: $failFindings }
                }
              },
              deployment: { aci: { name: $aciName, resourceGroup: $aciRg, url: $aciUrl } }
            }' > run.json
          test -s run.json
          ls -l run.json

      # Publish run.json alongside the SBOM and scan so the backend can stay in sync.
      - name: Upload RUN JSON to Azure Storage (flat name)
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        uses: azure/CLI@v2
        with:
          inlineScript: |
            set -euo pipefail
            test -s run.json || { echo "run.json not found"; pwd; ls -la; exit 2; }
            az storage blob upload --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_runs }}" --file run.json --name "${RUN_JSON_FILE}" --overwrite true --auth-mode login
            RUN_JSON_URL=$(az storage blob url --account-name "${AZURE_STORAGE_ACCOUNT}" --container-name "${{ steps.cfg.outputs.cn_runs }}" --name "${RUN_JSON_FILE}" -o tsv)
            echo "RUN_JSON_URL=$RUN_JSON_URL" >> $GITHUB_ENV

      # Keep a GitHub artifact copy of run.json for easy troubleshooting.
      - name: Upload RUN JSON artifact
        if: ${{ always() && steps.cfg.outputs.upload_artifacts == 'true' && hashFiles('run.json') != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: swft-run-json-${{ env.PROJECT_NAME }}-${{ env.TARGET_NAME }}-${{ env.RUN_ID }}-attempt${{ github.run_attempt }}
          path: run.json

      - name: Azure upload summary
        if: ${{ steps.cfg.outputs.upload_to_azure == 'true' }}
        run: |
            {
              echo "### Azure uploads"
              echo ""
              echo "- SBOM:  ${SBOM_URL:-'(n/a)'}"
              echo "- Trivy: ${TRIVY_URL:-'(n/a)'}"
              echo "- App design: ${APPDESIGN_URL:-'(n/a)'}"
              echo "- Run JSON: ${RUN_JSON_URL:-'(n/a)'}"
            } >> "$GITHUB_STEP_SUMMARY"
